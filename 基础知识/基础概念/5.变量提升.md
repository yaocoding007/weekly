注意理解一下 class 会不会提升 ？？



## 变量提升

#### javaScript中的 声明和赋值

```js
var name = '大魔王';

// 这段代码可能看成是两行代码组成的
var myname; // 声明部分
name = '大魔王'; // 赋值部分

/*-----------------------------*/

// 这是一个完整的函数声明， 也就是说没有涉及到赋值操作
function foo() {
   console.log('foo')
}

// 这个就是先声明了变量bar 再把函数赋值给bar
var bar = function() {
  console.log('bar');
}

```

> **所谓变量提升**： 
>
> 是指在js 代码执行过程中，js引擎把变量的声明部分和函数的声明部分提升到了代码开头的行为
>
> 变量被提升之后，会给变量设置默认值， 这个默认值就是我们熟悉的 undefined。



```js
showName()

var showName = function() {
  console.log(2)
}

function showName() {
  console.log(1)
}

// --> 1


// 这里要注意 第一行的代码执行的时候 变量对象上只有 函数声明的部分
// 而执行到这里的时候 赋值的操作就已经覆盖掉了 变量对象上函数声明的部分
// 也就是 同名的处理 只是在提升阶段 不是整个代码的执行阶段
// 下面的赋值操作 是会再次影响到 变量对象的
showName() // ---> 2

```



> 同名函数和同名变量的处理原则
>
> 1. 如果是同名的函数， javaScript 编译阶段会选择最后声明的那个
> 2. 如何变量和函数同名，那么在编译阶段，变量的声明会被忽略



#### 变量对象

变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明



1. 全局上下文的变量对象初始化是全局对象
2. 函数上下文的变量对象初始化只包括 Arguments 对象
3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
4. 在代码执行阶段会再次修改变量对象的属性值



参考: https://github.com/mqyqingfeng/Blog/issues/5





## let && const

>块级作用域的实现方式就是：
>
>​	把 let && const 声明的变量 放到 词法环境中去
>
>​	变量的查找 从词法环境的栈顶开始 -> 变量环境 -> outer(根据词法作用域的规则查找)
>
>要注意的点！！！
>
>​	1、var的创建和初始化被提升，赋值不会被提升
>​	2、let的创建被提升，初始化和赋值不会被提升 （let声明的变量提前使用会报错，会形成暂时性死区）
>​    3、function的创建、初始化和赋值均会被提升



变量提升是有缺陷的，导致很多与直觉不符的代码

1. 变量容易在不被察觉的情况被覆盖掉

2. 本应该被销毁的变量没有被销毁

   ```js
   function foo() {
     for(var i = 0; i < 7; i++) {
       
     }
     console.log(i)
   }
   foo()
   
   // 循环块内定义的变量 在执行结束后 没有被销毁
   ```

#### 如何解决这中缺陷? -> let && const 



```js
function foo() {
  var a = 1;
  let b = 2;
  {
    let b = 3;
    var c = 4;
    let d = 5;
    console.log(a)
    console.log(b)
  }
  console.log(b)
  console.log(c)
  console.log(d)
}
foo();
```

分析一下这段代码的执行过程

1. 编译并创建执行上下文

```js
// 变量环境中
a = undefined;
c = undefined;
// 词法环境中
b = undefined;

1、 函数内通过var 声明的变量，在编译阶段全都被存放到变量环境里面了。
2、 通过let 声明的变量，在编译阶段会被存放到 词法环境中。
3、 在函数的作用域块内部，通过let 声明的变量并没有被存放到词法环境中。
```

2. 继续执行代码

   ```js
   // 变量环境中
   a = 1;
   c = undefined;
   // 词法环境中
   b = undefined;
   d = undefined;
   
   b = 2;
   
   
   在词法环境内部 维护了一个小型栈结构 
   栈底是 函数最外层的变量，进入一个作用域快后， 就会把该作用域块内部的变量压到栈顶
   当作用域执行完成之后，改作用域的信息就会从栈顶弹出
   ```

   













